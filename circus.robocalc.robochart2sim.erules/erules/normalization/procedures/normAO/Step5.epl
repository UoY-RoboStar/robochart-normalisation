import "../../../common/RoboChart.eol";

// Initialization of variables, for example, before transformation.
pre {
	// Controls whether debug information is printed.
	var debug = true;
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	
	var count = 0;
	var countCRef = 0;
	
	//operations
	var usedOpSig = new Set(Source!OperationSig);
	var usedOpsNames = new Set(String);
	//clocks
	var usedClocksNames = new Set(String);
	
	//variables
	var usedVarsNames = new Set(String);
	var usedVarsEvParameters = new Set(Source!VariableList); 
	var usedVarsParameters; 
	var usedVarsParametersCl;
	var usedParsOpSig;
	var usedParsOpSig_AO;
	var usedVarsParameters_AO; 
	var usedVarsParametersCl_AO;

	var usedParsOpSig_deadlineActionOp_ActionOp;

	//events
	var usedEvsNames = new Set(String);
	
	//Getting the main package based on the parameter 'mainPkgRCT'
	var mainPackage;
	for (package in Source!RCPackage.all){
	   printDebug(" mainPackage in Step5 of smb " + package.name + " mainPkgRCT " + mainPkgRCT);
	   if (package.name.equals(mainPkgRCT)){
	       mainPackage = package;
	       printDebug(" mainPackage in Step5 of smb " + mainPackage);
	   }
	    
	}
	
}

// We can define operations.
operation printDebug(string) {
	if (debug) {(": "+string).println();}
}


pattern elim_parenthesis 
	 pkg : Source!RCPackage
		guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef from: pkg.operations,
	t 	: Source!Transition  from: opDef.transitions
	{
	match: 	not (t.action = null) and t.action.isKindOf(Source!ParStmt) 
	      
	do { 
		printDebug("begin elim-parenthesis ");
		t.action = t.action.stmt;
					
		if (debug) {
		    printDebug("Transition '" + t.name + "' from '" + t.source.name +  "' to '" + t.target.name + "' (action: " + t.action + ")");
	        printDebug("end elim-parenthesis ");
		}
	}
}

pattern split_sequence
	pkg : Source!RCPackage
		guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef from: pkg.operations,     
	t 	: Source!Transition from: opDef.transitions
	{
	match: 	not(t.action = null) and t.action.isKindOf(Source!SeqStatement) 
	do { 
	
	printDebug("begin split-sequence");
	printDebug("opDef.name " + opDef.name);
	printDebug("transition.name " + t.name + " t.action " + t.action);
	
	count = count+1;

		// A new junction is created, and a unique name based on the transition t's
		// name is given, plus the current size of the sequence. This is just an
		// example, but in general it may be possible to implement an operation
		// that walks the model to ensure locally unique names, thus obviating
		// the need for an explicit decision every time a new element is created.
	
	
		var newJunction = new Source!Junction();
		printDebug("t.action " + t.action + " opDef.name " + opDef.name);
		//newJunction.name = t.name + "_j_" + t.action.statements.size() + "_" + (count+1);
		newJunction.name = "j_" + t.action.statements.size() + "_" + (count+1);
		
		// A new Transition is created, whose source is t.source, and
		// whose target is the newState. Name uniqueness also ensured
		// by combining the name of 't' and the size of the sequence.
		var newTransition = new Source!Transition();
		//newTransition.name = t.name + "_t_" + t.action.statements.size() + "_" + (count+1);
		newTransition.name = "t_" + t.action.statements.size() + "_" + (count+1);
		newTransition.target = t.target;
		newTransition.source = newJunction;
		newTransition.action = t.action;
		
		t.action = newTransition.action.statements.removeAt(0);
		
		if (newTransition.action.statements.size = 1) {
			newTransition.action = newTransition.action.statements.first();
		}
		
		t.target = newJunction;
		
		opDef.nodes.add(newJunction);
		opDef.transitions.add(newTransition);
		
		if (debug) {
		 printDebug("Transition '" + t.name + "' from '" + t.source.name +  "' to '" + t.target.name + "' (action: " + t.action + ", trigger: "+ t.trigger +")");
		 printDebug("NewTransition '" + newTransition.name + "' from '" + newTransition.source.name +  "' to '" + newTransition.target.name + "' (action: " + newTransition.action + ", trigger: "+ newTransition.trigger +")");
		 printDebug("end split-sequence");	
	       
			
		}
	}
}


//New version with only two transitions, 
//and a junction between the condition and the action
//Updated 09/11 (MSCF)
pattern  split_conditional
	pkg : Source!RCPackage
		guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef from: pkg.operations,     
	t 	: Source!Transition from: opDef.transitions
	{
	match: not (t.source.isKindOf(Source!Initial)) and
	       not(t.action = null) and t.action.isKindOf(Source!IfStmt)

	do { 
	    printDebug("begin split-conditional");
	    
		// Two new junctions are created, and four new transitions are created.  
		// A unique name based on the transition t's name is adopted.  This is just an
		// example, but in general it may be possible to implement an operation
		// that walks the model to ensure locally unique names, thus obviating
		// the need for an explicit decision every time a new element is created.
		
		var thenJunction = new Source!Junction();
		thenJunction.name = t.name + "_thenJ_";
		var elseJunction = new Source!Junction();
		elseJunction.name = t.name + "_elseJ_";
		
		// Four new Transitions are created, two with source t.source, and
		// whose target are the thenJunction and elseJunction. Name uniqueness also ensured
		// by combining the name of 't' with some new strings.
		
		var thenTransition = new Source!Transition();
		var thenTransitionAction = new Source!Transition();
		// one transition for the condition
		thenTransition.name = t.name + "_thenTG_";
		thenTransition.source = t.source;
		thenTransition.target = thenJunction;
		thenTransition.condition = ecoreUtil.copy(t.action.expression);
		//thenTransition.action = t.action.then; //there is no action now
		// one transition with the original action	
		thenTransitionAction.name = t.name + "_thenTA_";
		thenTransitionAction.source = thenJunction;
		thenTransitionAction.target = t.target;
		thenTransitionAction.action = t.action.then;
		//
		var elseTransition = new Source!Transition();
		var elseTransitionAction = new Source!Transition();
		
		elseTransition.name = t.name + "_elseTG_";
		elseTransition.source = t.source;
		elseTransition.target = elseJunction;//t.target;
		elseTransition.condition = new Not(); 
		elseTransition.condition.exp = t.action.expression;
		//elseTransition.action = t.action.`else`; //there is no action now
		//
		/*var elseTransitionAction = new Source!Transition();*/
		elseTransitionAction.name = t.name + "_elseTA_";
		elseTransitionAction.source = elseJunction;
		elseTransitionAction.target = t.target;
		elseTransitionAction.action = t.action.`else`; 
		
		//printDebug("before adding junctions and transitions");
		
       // Missing: add new junctions and transitions, remove t, check containement attributes
		opDef.transitions.addAll(Set{thenTransition,thenTransitionAction, elseTransition,
		                             elseTransitionAction});
		opDef.transitions.remove(t);
		delete(t);
		opDef.nodes.addAll(Set{thenJunction,elseJunction});
		
		
		if (debug) {
		    printDebug("Transition '" + t.name + "' from '" + t.source.name +  "' to '" + t.target.name + "' (action: " + t.action + ")");
		    printDebug("end split conditional");
		}
	}
}

pattern intro_junction_from_initial_junction
	pkg : Source!RCPackage
		guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef from: pkg.operations,     
	t 	: Source!Transition from: opDef.transitions{
	match: 	t.source.isKindOf(Source!Initial) and
	        (  (t.action.isKindOf(Source!IfStmt)) ) 
	do { 
      printDebug("begin  intro-junction-from-initial-junction ");
           var newJunction = new Source!Junction();
	       newJunction.name = t.name + "_initialJunction_";
		    
		   var tinitial = new Source!Transition();
		   tinitial.name = t.name + "_initial_";
		   tinitial.source = t.source;
		   tinitial.target = newJunction;
		   
		   t.source = newJunction;
		   opDef.nodes.add(newJunction);
		   opDef.transitions.add(tinitial);
    }
    }
    
operation usedVars(s:Source!Statement) {

    /*var usedVarList = new Set(Source!VariableList);
	
	// Compute all objects of the metamodel that are contained by transitivity in s.
	var statementContents = s.closure(x|x.eContents());
	
	// We calculate two sets, the variables in a 'VarRef' and those in a 'RefExp'.
	var varrefs = statementContents.select(y:Source!VarRef|true).collect(z:Source!VarRef|z.name).asSet();
	//var varexps = contents.select(y:Source!RefExp|true).collect(z:Source!RefExp|z.ref).asSet();
	var varexps = statementContents.select(y:Source!RefExp|not(y.ref.isTypeOf(Source!Function))).collect(z:Source!RefExp|z.ref).asSet();
	
	// An Interface is a BasicContext, which can have sequences of VariableList elements,
	// so we create a new VariableList and add this to the sequence.
	var variableList = new Source!VariableList();
	var constantList = new Source!VariableList();
	usedVarsNames = new Set(String);
	
	variableList.modifier = Source!VariableModifier#VAR;	// Variables
	constantList.modifier = Source!VariableModifier#CONST; 	// Constants
			
	printDebug("varrefs " + varrefs);
	printDebug("varexps " + varexps);
	    
	//OK, but error with required variables
	for (v in (varrefs+varexps)){      
	       var newVar = ecoreUtil.copy(v);
	       usedVarsNames.add(newVar.name);
	       if (v.modifier == Source!VariableModifier#VAR)
			variableList.vars.add(newVar);
		   else
			constantList.vars.add(newVar);	       
			
	        // Update all variable references to the old variable declaration 'v' => newVar.
			for (varref in statementContents.select(x:Source!VarRef|x.name = v)) {
				varref.name = newVar;
			}
			// Update all expression references to the old variable declaration 'v' => newVar.
			for (refexp in statementContents.select(x:Source!RefExp|x.ref = v)) {
				refexp.ref = newVar;
			}
		
	    }
	    
	 // In principle, we could add empty lists.. but here we make sure not to do so.
	if (variableList.vars.size > 0) {
		usedVarList.add(variableList);
	} else {
		delete variableList;
	}
	
	if (constantList.vars.size > 0){
		usedVarList.add(constantList);
	} else {
		delete constantList;
	}
	
	return usedVarList;
*/

    usedVarsNames = new Set(String);
    usedVarsParameters = new Set(Source!Parameter);
    usedVarsParametersCl = new Set(Source!Parameter);
    
    //usedVarsParametersAO = new Set(Source!Parameter);
    //usedVarsParametersAOCl = new Set(Source!Parameter);
    var usedVarList = new Set(Source!VariableList);
	
	// Compute all objects of the metamodel that are contained by transitivity in s.
	var statementContents = s.closure(x|x.eContents());
	
	// We calculate two sets, the variables in a 'VarRef' and those in a 'RefExp'.
	var varrefs = statementContents.select(y:Source!VarRef|true).collect(z:Source!VarRef|z.name).asSet();
	var varexps = statementContents.select(y:Source!RefExp|not(y.ref.isTypeOf(Source!Function))).collect(z:Source!RefExp|z.ref).asSet();
	var commInput = statementContents.select(x:Source!Communication|x._type == CommunicationType#INPUT).collect(z:Source!Communication|z).asSet();
	// An Interface is a BasicContext, which can have sequences of VariableList elements,
	// so we create a new VariableList and add this to the sequence.
	
	//Parameters
	var parexps = statementContents.select(y:Source!RefExp|y.ref.isTypeOf(Source!Parameter)).collect(z:Source!RefExp|z.ref).asSet();
	printDebug(" parexps " + parexps);	  
	
	var variableList = new Source!VariableList();
	var constantList = new Source!VariableList();
	
	variableList.modifier = Source!VariableModifier#VAR;	// Variables
	constantList.modifier = Source!VariableModifier#CONST; 	// Constants
	
	//It is used to store the parameters (variables) of a input communication 
	var varsCommInput = new Set(Source!Variable);
	if (commInput.notEmpty()){
	    for (inp in commInput){
	        //printDebug(" s.communication.parameter " + inp.parameter);
	        varsCommInput.add(inp.parameter);
		    //printDebug("varsCommInput " + varsCommInput);     
	    }  
	}		
	   
	for (v in (varrefs+varexps+varsCommInput+parexps)){ 
	       
	       
	       if (v.isTypeOf(Source!Parameter)){
	         var newPar = ecoreUtil.copy(v);
	         usedVarsParameters.add(v);
	         usedVarsParametersCl.add(newPar);
	         for (refexp in statementContents.select(x:Source!RefExp|x.ref = v)) {
				refexp.ref = newPar;
				printDebug(" v.isTypeOf(Source!Parameter) " + refexp.ref + "" + refexp);
			}
	         
	       } 
	         
	       else { 
	       
	       var newVar = ecoreUtil.copy(v);
	       printDebug(" newVar " + newVar);
	       usedVarsNames.add(newVar.name);
	       
	       if (v.modifier == Source!VariableModifier#VAR){
			variableList.vars.add(newVar);
			//printDebug(" v.modifier == Source!VariableModifier#VAR ");
			}
		   else{
			constantList.vars.add(newVar);
			//printDebug(" v.modifier == const ");
			}	       
			
	        // Update all variable references to the old variable declaration 'v' => newVar.
			for (varref in statementContents.select(x:Source!VarRef|x.name = v)) {
				varref.name = newVar;
				//printDebug(" newVar " + newVar);
			}
			// Update all expression references to the old variable declaration 'v' => newVar.
			for (refexp in statementContents.select(x:Source!RefExp|x.ref = v)) {
				refexp.ref = newVar;
				//printDebug(" refexp newVar " + newVar);
			}
			for (commInput in statementContents.select(x:Source!Communication|x._type == CommunicationType#INPUT
			        and x.parameter = v)) {
			          commInput.parameter = newVar;
		    }
			}
		
	    }
	    
	 // In principle, we could add empty lists.. but here we make sure not to do so.
	if (variableList.vars.size > 0) {
		usedVarList.add(variableList);
	} else {
		delete variableList;
	}
	
	if (constantList.vars.size > 0){
		usedVarList.add(constantList);
	} else {
		delete constantList;
	}
	
	printDebug(" usedVarList " + usedVarList);
	return usedVarList;
}

operation usedVars_AO(s:Source!Statement) {

    usedVarsNames = new Set(String);
    usedVarsParameters_AO = new Set(Source!Parameter);
    usedVarsParametersCl_AO = new Set(Source!Parameter);
    
    //usedVarsParametersAO = new Set(Source!Parameter);
    //usedVarsParametersAOCl = new Set(Source!Parameter);
    var usedVarList = new Set(Source!VariableList);
	
	// Compute all objects of the metamodel that are contained by transitivity in s.
	var statementContents = s.closure(x|x.eContents());
	
	// We calculate two sets, the variables in a 'VarRef' and those in a 'RefExp'.
	var varrefs = statementContents.select(y:Source!VarRef|true).collect(z:Source!VarRef|z.name).asSet();
	var varexps = statementContents.select(y:Source!RefExp|not(y.ref.isTypeOf(Source!Function))).collect(z:Source!RefExp|z.ref).asSet();
	var commInput = statementContents.select(x:Source!Communication|x._type == CommunicationType#INPUT).collect(z:Source!Communication|z).asSet();
	// An Interface is a BasicContext, which can have sequences of VariableList elements,
	// so we create a new VariableList and add this to the sequence.
	
	//Parameters
	var parexps = statementContents.select(y:Source!RefExp|y.ref.isTypeOf(Source!Parameter)).collect(z:Source!RefExp|z.ref).asSet();
	printDebug(" parexps " + parexps);	  
	
	var variableList = new Source!VariableList();
	var constantList = new Source!VariableList();
	
	variableList.modifier = Source!VariableModifier#VAR;	// Variables
	constantList.modifier = Source!VariableModifier#CONST; 	// Constants
	
	//It is used to store the parameters (variables) of a input communication 
	var varsCommInput = new Set(Source!Variable);
	if (commInput.notEmpty()){
	    for (inp in commInput){
	        //printDebug(" s.communication.parameter " + inp.parameter);
	        varsCommInput.add(inp.parameter);
		    //printDebug("varsCommInput " + varsCommInput);     
	    }  
	}		
	   
	for (v in (varrefs+varexps+varsCommInput+parexps)){ 
	       
	       
	       if (v.isTypeOf(Source!Parameter)){
	         var newPar = ecoreUtil.copy(v);
	         usedVarsParameters_AO.add(v);
	         usedVarsParametersCl_AO.add(newPar);
	         for (refexp in statementContents.select(x:Source!RefExp|x.ref = v)) {
				refexp.ref = newPar;
				printDebug(" v.isTypeOf(Source!Parameter) " + refexp.ref + "" + refexp);
			}
	         
	       } 
	         
	       else { 
	       
	       var newVar = ecoreUtil.copy(v);
	       printDebug(" newVar " + newVar);
	       usedVarsNames.add(newVar.name);
	       
	       if (v.modifier == Source!VariableModifier#VAR){
			variableList.vars.add(newVar);
			//printDebug(" v.modifier == Source!VariableModifier#VAR ");
			}
		   else{
			constantList.vars.add(newVar);
			//printDebug(" v.modifier == const ");
			}	       
			
	        // Update all variable references to the old variable declaration 'v' => newVar.
			for (varref in statementContents.select(x:Source!VarRef|x.name = v)) {
				varref.name = newVar;
				//printDebug(" newVar " + newVar);
			}
			// Update all expression references to the old variable declaration 'v' => newVar.
			for (refexp in statementContents.select(x:Source!RefExp|x.ref = v)) {
				refexp.ref = newVar;
				//printDebug(" refexp newVar " + newVar);
			}
			for (commInput in statementContents.select(x:Source!Communication|x._type == CommunicationType#INPUT
			        and x.parameter = v)) {
			          commInput.parameter = newVar;
		    }
			}
		
	    }
	    
	 // In principle, we could add empty lists.. but here we make sure not to do so.
	if (variableList.vars.size > 0) {
		usedVarList.add(variableList);
	} else {
		delete variableList;
	}
	
	if (constantList.vars.size > 0){
		usedVarList.add(constantList);
	} else {
		delete constantList;
	}
	
	printDebug(" usedVarList " + usedVarList);
	return usedVarList;
}

operation usedOps(s:Source!Statement) {

    var usedOps = new Set(Source!OperationSig);
    usedOpSig = new Set(Source!OperationSig);
    //usedOpsNames = new Set(String);
	// Compute all objects of the metamodel that are contained by transitivity in s.
	var statementContents = s.closure(x|x.eContents());
	var contents = statementContents.select(y:Source!Call|true).collect(z:Source!Call|z.`operation`).asSet();
	
	for (op in contents){
	    
		var newOpSig = ecoreUtil.copy(op);
        	
		for (stmt in statementContents.select(x:Source!Call|x.`operation` = op)) {
			stmt.`operation` = newOpSig;
		}
		//Adding newOpSig into the Interface
		usedOps.add(newOpSig);
		usedOpSig.add(newOpSig);
		usedOpsNames.add(newOpSig.name);
		
      } 
   return usedOps;
       
}

operation usedClocks(s:Source!Statement){

  var usedClocks = new Set(Source!Clock);
  usedClocksNames = new Set(String);
  
  // Compute all objects of the metamodel that are contained by transitivity in s.
  var statementContents = s.closure(x|x.eContents());
  var contents = statementContents.select(x:Source!ClockReset|true).collect(z:Source!ClockReset|z.clock).asSet();  
  
  for (c in contents){
      // Create the new clock declaration
	  var newClock = ecoreUtil.copy(c);   
      // Replace all clock references
		for (stmt in statementContents.select(x:Source!ClockReset|x.clock = c)) {
		    //printDebug("t.clock " + t.clock);
			stmt.clock = newClock;
		}
		
	  usedClocks.add(newClock);
	  usedClocksNames.add(newClock.name);
  }
  
  if (s.isKindOf(Source!ClockReset)){
     printDebug("s.isKindOf(Source!ClockReset) " + s.clock.name);
     var newClock = ecoreUtil.copy(s.clock);
     s.clock = newClock;
     usedClocks.add(newClock);
     usedClocksNames.add(newClock.name);
  }
  
  return usedClocks;
}

operation usedEvents(s:Source!Statement) {
	
	var usedEvents = new Set(Source!Event);
	usedEvsNames = new Set(String);
	// Compute all objects of the metamodel that are contained by transitivity in s.
	var statementContents = s.closure(x|x.eContents());
	var contents = statementContents.select(x:Source!Communication|true).collect(z:Source!Communication|z.event).asSet();

    for (ev in contents) {
        printDebug("ev " + ev);	
        var newEvent = ecoreUtil.copy(ev);
		printDebug("newEvent " + newEvent);	
		for (stmt in statementContents.select(x:Source!Communication|x.event = ev)) {
			stmt.event = newEvent;
		}
		usedEvents.add(newEvent);
		usedEvsNames.add(newEvent.name);
    }
    
   return usedEvents;
	
}

operation reqVarsOps(s:Source!Statement) {

    var variableList = new Source!VariableList();
	var constantList = new Source!VariableList();
	
	variableList.modifier = Source!VariableModifier#VAR;	// Variables
	constantList.modifier = Source!VariableModifier#CONST; 	// Constants
	
    var reqVarsOps = new Set(Source!VariableList);
   
    var softOpNames = collectSoftwareOperationsName();
    var softOps = collectSoftwareOperations();
   
    for(op in usedOpSig){
          if (softOpNames.includes(op.name)){
            var operationDef = softOps.selectOne(opDef:Source!OperationDef|opDef.name.equals(op.name));          
            var reqInterfaces = operationDef.rInterfaces.select(i|i.variableList.size()>0).asSet();
            for (r in reqInterfaces){ 
		      	for (vl in r.variableList){
		      	  for (v in vl.vars){
		      	  	if (not usedVarsNames.includes(v.name)){
		      	    	printDebug("usedVarsNames.includes(v.name) " + v.name);
		      	    	var newVar = ecoreUtil.copy(v);
		      	    	if (v.modifier == Source!VariableModifier#VAR)
							variableList.vars.add(newVar);
		   	            else
							constantList.vars.add(newVar);	 
		      	    	usedVarsNames.add(newVar.name);
		          }
		        } 
		 
		      }
       
          }
           // In principle, we could add empty lists.. but here we make sure not to do so.
			if (variableList.vars.size > 0) {
				reqVarsOps.add(variableList);
			} else {
				delete variableList;
			}
	
			if (constantList.vars.size > 0){
				reqVarsOps.add(constantList);
			} else {
				delete constantList;
			}
       }
    
   }
   return reqVarsOps;
       
}


operation reqClocksOps(s:Source!Statement) {

    var reqClocksOpS = new Set(Source!Clock);
    var softOps = collectSoftwareOperations();
    var softOpNames = collectSoftwareOperationsName();
    printDebug("In reqClocksOps: softOpNames " + softOpNames);
    printDebug("In reqClocksOps: usedOpSig " + usedOpSig);
    for(op in usedOpSig){
          if (softOpNames.includes(op.name)){
            var operationDef = softOps.selectOne(opDef:Source!OperationDef|opDef.name.equals(op.name));          
            var reqInterfaces = operationDef.rInterfaces.select(i|i.clocks.size()>0).asSet();
               for (r in reqInterfaces){                
       		      	for (cl in r.clocks){
    		      	  	if (not usedClocksNames.includes(cl.name)){
  		      	  	    	var newClk = ecoreUtil.copy(cl);
		      	        	reqClocksOpS.add(newClk);
		      	        	usedClocksNames.add(newClk.name);
    		          }
  		             
		        } 
 		      
			}
         
       }
    
   }
   return reqClocksOpS;
       
}

operation defEvOps(s:Source!Statement) {
	
    var defEvOps = new Set(Source!Event);
    var softOps = collectSoftwareOperations();
    var softOpNames = collectSoftwareOperationsName();
   
     for(op in usedOpSig){
          if (softOpNames.includes(op.name)){
            var operationDef = softOps.selectOne(opDef:Source!OperationDef|opDef.name.equals(op.name));  
            var interfaces = operationDef.interfaces.select(i|i.events.size()>0).asSet();
               for (i in interfaces){                
       		      	for (ev in i.events){
    		      	  	if (not usedEvsNames.includes(ev.name)){
  		      	  	      var newEv = ecoreUtil.copy(ev);
		      	          defEvOps.add(newEv);
		      	          usedEvsNames.add(newEv.name);
    		          }
		        } 	      
			}
			for (ev in operationDef.events){
			//printDebug(" local ev " + ev.name);
			   if (not usedEvsNames.includes(ev.name)){
  		      	  	  var newEv = ecoreUtil.copy(ev);
		      	      defEvOps.add(newEv);
		      	      usedEvsNames.add(newEv.name);
    		    }
			
			}
       }
    
   }
   return defEvOps;
}

operation usedPars(opDef:Source!OperationDef){
   var usedPars = new Sequence(Sorce!Parameter);
   usedParsOpSig = new Sequence(Sorce!Parameter);
		if(usedVarsParametersCl.notEmpty()){
		  printDebug(" in usedPars OpDef");
		  for (p in opDef.parameters){
		     for (np in usedVarsParametersCl){
		       if (p.name.equals(np.name)){
		         var parOpSig = ecoreUtil.copy(np);
		         usedPars.add(np);
		         usedParsOpSig.add(parOpSig);
		         printDebug("p.name.equals(np.name) " + np + " " + np.name + " " + np.type );
		       }
		     }
		  }
  }
  return usedPars;
}

operation usedPars_AO(opDef:Source!OperationDef){
   var usedPars = new Sequence(Sorce!Parameter);
   usedParsOpSig_AO = new Sequence(Sorce!Parameter);
		if(usedVarsParametersCl.notEmpty()){
		  printDebug(" in usedPars_AO OpDef");
		  for (p in opDef.parameters){
		     for (np in usedVarsParametersCl_AO){
		       if (p.name.equals(np.name)){
		         var parOpSig = ecoreUtil.copy(np);
		         usedPars.add(np);
		         usedParsOpSig_AO.add(parOpSig);
		         printDebug("p.name.equals(np.name) " + np + " " + np.name + " " + np.type );
		       }
		     }
		  }
  }
  return usedPars;
}
    
pattern elim_deadline_action
	pkg : Source!RCPackage
		guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef 
	    from: pkg.operations,     
	t 	: Source!Transition from: opDef.transitions
	{
		// One of the transitions with deadline	
	match:  not(t.action = null) and t.action.isKindOf(Source!TimedStatement) 
            and not (opDef.name = "deadlineCheck")
	do {
		////////////////////////////////////////////////////////////////////////////////////////////////
		//count=count+1;
		usedVarsNames = new Set(String);
		printDebug("begin elim_deadline_action"); 
		printDebug(opDef.name + " " + opDef); 
		printDebug("transition.name " + t.name + " opDef.name " + opDef.name + " t.action "  + t.action);
		
		// Create interfaces to hold new declarations for variables/operations/clocks/events used by this action.
		var req_s 	= new Source!Interface();
		req_s.name 	= "req_" + opDef.name + "_" + t.name;//setName(opDef,S,s);
		
		var defEvents_s	= new Source!Interface();
		defEvents_s.name 	= "defEvents_" + opDef.name + "_" + t.name;
		
		var req_normal 	= new Source!Interface();
		req_normal.name 	= "req_normal_" + opDef.name + "_S0_" + t.name;//setName(opDef,S,s);
		
		var defEvents_normal	= new Source!Interface();
		defEvents_normal.name 	= "defEvents_normal_" + opDef.name + "_S0_" + t.name;
		
		//Capturing the variables used by s
		var usedVars = usedVars(t.action.stmt);	
		/*Capturing the (software and platform) operations used by s
		  and for each software operation (IOpS) in usedOps, 
		  we need to compute its required variables and clocks required by op, and theirs defined events
        */
		var usedOps = usedOps(t.action.stmt);		
		var usedClocks = usedClocks(t.action.stmt);		
		var reqVarsOps = reqVarsOps(t.action.stmt);		
		var reqClocksOps = reqClocksOps(t.action.stmt);		
		var usedEvents = usedEvents(t.action.stmt);		
		var defEvOps = defEvOps(t.action.stmt);
		
		if (usedVars.notEmpty()) { req_s.variableList.addAll(usedVars); }
		if (usedOps.notEmpty()) {req_s.operations.addAll(usedOps); }
		if (usedClocks.notEmpty()) {req_s.clocks.addAll(usedClocks); }
		if (reqVarsOps.notEmpty()) { req_s.variableList.addAll(reqVarsOps);}
		if (reqClocksOps.notEmpty()) {req_s.clocks.addAll(reqClocksOps); }
		if (usedEvents.notEmpty())
		{//printDebug("usedEvents.notEmpty() is not empty");
		defEvents_s.events.addAll(usedEvents);}
		//else printDebug("usedEvents.notEmpty() is empty");
		
		if (defEvOps.notEmpty()){defEvents_s.events.addAll(defEvOps);}
		
	    // Create the new operation, and a new signature for inclusion in the interface.
		var deadlineActionOp    = new Source!OperationDef();
		deadlineActionOp.name 	= "deadlineAction_" + opDef.name + "_" + t.name;
	
        // parameter for the deadlineInAction operationDef - op
		var parD = new Source!Parameter();
		parD.name = "d";
		var parDtype = new Source!TypeRef();
		parDtype.ref = Source!PrimitiveType.all.selectOne(p|p.name="nat");
		parD.type = parDtype;
		//deadlineActionOp.parameters.add(parD);
		
		// The operation has an initial junction, a composite state, and a final state.
		var deadlineActionOp_I 	= new Source!Initial();
		deadlineActionOp_I.name	= "i"; // + "_" + (count+1);
		var deadlineActionOp_S0 	= new Source!State();
		deadlineActionOp_S0.name 	= "S0";
		var deadlineActionOp_F 	= new Source!Final();
		deadlineActionOp_F.name 	= "f"; //+ "_" + (count+1);
		
		//Creating the variable g for the new operation
		var newVar_g = new Source!Variable();
		newVar_g.name = "g"; 
		
		var newVar_g_type = new Source!TypeRef();
		newVar_g_type.ref = Source!PrimitiveType.all.selectOne(p|p.name="boolean");
		newVar_g.type = newVar_g_type;

		var initialValue_g = new Source!BooleanExp();
		initialValue_g.value = "false";	
		newVar_g.initial = initialValue_g;

        // Attributes of deadlineActionOp
		// 1 - Adding the variable g to deadlineActionOp
		var variableList = new Source!VariableList();
		variableList.vars.add(newVar_g);
		variableList.modifier = VariableModifier#VAR;
		deadlineActionOp.variableList.add(variableList); 
		
		// 2 - op requires IdeadlineCheck
		//IdeadlineCheck
		/*For generality: 
         here, we need to update: we need to create a rct with the deadline operations (and interfaces),
         as well as wait operations (and their interfaces):
		 So, to get the interface IdeadlineCheck, we need to acess such a file, and
         var interface = pkg.interfaces.selectOne(i | i.name = "IdeadlineCheck"); 

        
		for (i in pkg.interfaces){
		 //printDebug("i in pkg.interfaces " + i.name);
		  if (i.name.equals("IdeadlineCheck")){
		   // printDebug("interface " + i.name);
		  }
		  
		}*/
		
		
		// Attributes of the composite state deadlineActionOp_S0
		var deadlineActionOp_S0_I 	= new Source!Initial();
		deadlineActionOp_S0_I.name	= "i";
		var deadlineActionOp_S0_S1 	= new Source!State();
		deadlineActionOp_S0_S1.name = "S1";
		var deadlineActionOp_S0_F 	= new Source!Final();
		deadlineActionOp_S0_F.name 	= "f";
		
		//Creating the during action (during deadlineCheck) for deadlineActionOp_S0
		var duringAction = new DuringAction();
		duringAction.action = new Call();
		
		var IdeadlineCheck = pkg.interfaces.selectOne(i | i.name = "IdeadlineCheck");
		if (IdeadlineCheck == null){
			printDebug("IdeadlineCheck is null");
		}
		else printDebug("IdeadlineCheck is not null");
		
		var deadlineCheckOpSig = IdeadlineCheck.operations.selectOne(op | op.name = "deadlineCheck");
		duringAction.action.`operation` = deadlineCheckOpSig;
		// Adding the IdeadlineCheck to deadlineAction
		deadlineActionOp.rInterfaces.add(IdeadlineCheck);
		//adding the arguments for deadlineCheck
		var rfDuringAction = new Source!RefExp();
		rfDuringAction.ref = parD;
		duringAction.action.args.add(rfDuringAction);  
		
		//Adding the action to deadlineActionOp_S0
		deadlineActionOp_S0.actions.add(duringAction);
		
		//Creating the transitions of the composite state S0
		//It has two transitions: from deadlineActionOp_S0_I to deadlineActionOp_S0_S1
		var deadlineActionOp_S0_Tr = new Source!Transition();
		deadlineActionOp_S0_Tr.name	  = "t0";
		deadlineActionOp_S0_Tr.source = deadlineActionOp_S0_I;
		deadlineActionOp_S0_Tr.target = deadlineActionOp_S0_S1;
		
		// It also has a transition from deadlineActionOp_S0_S1 to deadlineActionOp_S0_F
		var deadlineActionOp_S0_Tr1 = new Source!Transition();
		deadlineActionOp_S0_Tr1.name	= "t1";
		deadlineActionOp_S0_Tr1.source = deadlineActionOp_S0_S1;
		deadlineActionOp_S0_Tr1.target = deadlineActionOp_S0_F;
		
		//Creating the action of the transition deadlineActionOp_S0_Tr1, which is a Call (action operation)
		//First, we create the action operation
		var deadlineActionOp_ActionOp 	= new Source!OperationDef();
		deadlineActionOp_ActionOp.name 	= "normal_" + deadlineActionOp.name;
		
		//This new operation (normal_deadlineAction_) contains two nodes (it is an action operation)
		//Nodes of the action operation normal_deadlineAction_
		var deadlineActionOp_ActionOp_I 	= new Source!Initial();
		deadlineActionOp_ActionOp_I.name	= "i";
		var deadlineActionOp_ActionOp_F 	= new Source!Final();
		deadlineActionOp_ActionOp_F.name 	= "f";
		
		//The single transition of the action operation normal_deadlineAction_
		var deadlineActionOp_ActionOp_Tr    = new Source!Transition();
		deadlineActionOp_ActionOp_Tr.name	= "t";
		deadlineActionOp_ActionOp_Tr.source = deadlineActionOp_ActionOp_I;
		deadlineActionOp_ActionOp_Tr.target = deadlineActionOp_ActionOp_F;
		
		//Creating the action of this transition; it is a SeqStatement
		var deadlineActionOp_ActionOp_SeqStatement = new Source!SeqStatement();
		var deadlineActionOp_ActionOp_SeqStatement1 = t.action.stmt;
		
		
		usedOpSig = new Set(Source!OperationSig);
	    usedOpsNames = new Set(String);
	    //clocks
	    usedClocksNames = new Set(String);
	    //variables
	    usedVarsNames = new Set(String);
	    //events
	    usedEvsNames = new Set(String);
		
		var usedVarsAO = usedVars_AO(deadlineActionOp_ActionOp_SeqStatement1);	
		var usedOpsAO = usedOps(deadlineActionOp_ActionOp_SeqStatement1);		
		var usedClocksAO = usedClocks(deadlineActionOp_ActionOp_SeqStatement1);		
		var reqVarsOpsAO = reqVarsOps(deadlineActionOp_ActionOp_SeqStatement1);		
		var reqClocksOpsAO = reqClocksOps(deadlineActionOp_ActionOp_SeqStatement1);		
		var usedEventsAO = usedEvents(deadlineActionOp_ActionOp_SeqStatement1);		
		var defEvOpsAO = defEvOps(deadlineActionOp_ActionOp_SeqStatement1);
		
		if (usedVarsAO.notEmpty()) { req_normal.variableList.addAll(usedVarsAO); }
		if (usedOpsAO.notEmpty()) {req_normal.operations.addAll(usedOpsAO); }
		if (usedClocksAO.notEmpty()) {req_normal.clocks.addAll(usedClocksAO); }
		if (reqVarsOpsAO.notEmpty()) { req_normal.variableList.addAll(reqVarsOpsAO); }
		if (reqClocksOpsAO.notEmpty()) { req_normal.clocks.addAll(reqClocksOpsAO);}
		if (usedEventsAO.notEmpty())
		{printDebug("usedEvents.notEmpty() is not empty");
		defEvents_normal.events.addAll(usedEventsAO);}
		else printDebug("usedEvents.notEmpty() is empty");
		if (defEvOpsAO.notEmpty()){defEvents_normal.events.addAll(defEvOpsAO);}
		
		
		
		//Creating VarRef g=true
		//First, we make a copy of g
		var gActOp = ecoreUtil.copy(newVar_g);
		gActOp.name = "g";
		var varRefActOp = new Source!VarRef();
	    varRefActOp.name = gActOp;
		var trueVarActOp = new Source!BooleanExp();
		trueVarActOp.value = "true";
		//Setting the second action of the SeqStatement
		var deadlineActionOp_ActionOp_SeqStatement2 = new Source!Assignment();
		deadlineActionOp_ActionOp_SeqStatement2.left = varRefActOp;
		deadlineActionOp_ActionOp_SeqStatement2.right = trueVarActOp;
		
		deadlineActionOp_ActionOp_SeqStatement.statements.addAll(Sequence{deadlineActionOp_ActionOp_SeqStatement1,deadlineActionOp_ActionOp_SeqStatement2});
		
		//It did not find diff
		deadlineActionOp_ActionOp_Tr.action = deadlineActionOp_ActionOp_SeqStatement; //t.action.stmt; //Its action is the original action of opDef (stmt)
		//deadlineActionOp_ActionOp_Tr.action = deadlineActionOp_ActionOp_SeqStatement2;
		//Adding nodes of deadlineActionOp_ActionOp
		deadlineActionOp_ActionOp.nodes.addAll(Set{deadlineActionOp_ActionOp_I,deadlineActionOp_ActionOp_F});
		//Adding the single transition of opActOp
		deadlineActionOp_ActionOp.transitions.add(deadlineActionOp_ActionOp_Tr);
		
		//Adding the parameters for deadlineActionOp_ActionOp
		 
		usedParsOpSig_AO = new Sequence(Sorce!Parameter);
		var usedPars_deadlineActionOp_ActionOp = new Sequence(Sorce!Parameter);
		usedPars_deadlineActionOp_ActionOp.addAll(usedPars_AO(opDef));
		if (usedPars_deadlineActionOp_ActionOp.notEmpty()){
		    printDebug(" usedPars_deadlineActionOp_ActionOp.notEmpty() " + usedPars_deadlineActionOp_ActionOp);
			//deadlineActionOp_ActionOp.parameters.addAll(usedPars_deadlineActionOp_ActionOp);
			var seqPars = new Sequence(Sorce!Parameter);
			for (p in usedPars_deadlineActionOp_ActionOp){
			   seqPars.add(p);
			}
			deadlineActionOp_ActionOp.parameters.addAll(seqPars);
			printDebug(" deadlineActionOp_ActionOp.parameters " + deadlineActionOp_ActionOp.parameters);
		}
		
		
		
		//Creating the Signature for deadlineActionOp_ActionOp
		var deadlineActionOp_ActionOpSig  = new Source!OperationSig();
		deadlineActionOp_ActionOpSig.name = deadlineActionOp_ActionOp.name;
		if(usedPars_deadlineActionOp_ActionOp.notEmpty()){
		   deadlineActionOp_ActionOpSig.parameters.addAll(usedParsOpSig_AO);
		   printDebug(" deadlineActionOp_ActionOpSig.parameters " + usedParsOpSig_AO);
		}
		   
		
		
		//Creating the call to deadlineActionOp (normal_deadlineAction_)
		var callActOp = new Source!Call();
		callActOp.`operation` = deadlineActionOp_ActionOpSig;
		deadlineActionOp_S0_Tr1.action = callActOp;
		
		if (usedPars_deadlineActionOp_ActionOp.notEmpty()){
		printDebug( " usedVarsParameters_AO " + usedVarsParameters_AO);
		var seqArgs = new Sequence(Sorce!Expression);
		   for (p in opDef.parameters){
		     for (np in usedVarsParameters_AO){
		       if (p.name.equals(np.name)){
		         var refExp = new Source!RefExp();
		         refExp.ref = np;
		         seqArgs.add(refExp);
		         //printDebug("opsig args " + np + " " + np.name + " " + np.type );
		         //printDebug("opsig refexp " + refExp  );
		       }
		     }
		     }
		     deadlineActionOp_S0_Tr1.action.args.addAll(seqArgs);
		}

		//Adding the nodes and transition of deadlineActionOp_S0
		deadlineActionOp_S0.nodes.addAll(Set{deadlineActionOp_S0_I,deadlineActionOp_S0_S1,deadlineActionOp_S0_F});
		deadlineActionOp_S0.transitions.addAll(Set{deadlineActionOp_S0_Tr,deadlineActionOp_S0_Tr1});
		
		//Now, we create the transitions of the main operation deadlineAction
		// deadlineAction has two transitions
		// (1) - from deadlineActionOp_I to deadlineActionOp_S0
		var deadlineActionOp_Tr = new Source!Transition();
		deadlineActionOp_Tr.name	  = "t0";
		deadlineActionOp_Tr.source = deadlineActionOp_I;
		deadlineActionOp_Tr.target = deadlineActionOp_S0;	
		
		// (2) - from deadlineActionOp_S0 to deadlineActionOp_F
		var deadlineActionOp_Tr1 = new Source!Transition();
		deadlineActionOp_Tr1.name	  = "t1";
		deadlineActionOp_Tr1.source = deadlineActionOp_S0;
		deadlineActionOp_Tr1.target = deadlineActionOp_F;
			
		//Creating RefExp [g]
		var refExp = new Source!RefExp();
		refExp.ref = newVar_g;
		deadlineActionOp_Tr1.condition = refExp;
		
		//Adding nodes and transition of deadlineActionOp
		deadlineActionOp.nodes.addAll(Set{deadlineActionOp_I,deadlineActionOp_S0,deadlineActionOp_F});
		deadlineActionOp.transitions.addAll(Set{deadlineActionOp_Tr,deadlineActionOp_Tr1});
		
		//deadling with parameters
		var usedPars = new Sequence(Sorce!Parameter);
		usedParsOpSig = new Sequence(Sorce!Parameter);
		
		usedPars.addAll(usedPars(opDef));
		if (usedPars.notEmpty()){
		    usedPars.add(parD);
			deadlineActionOp.parameters.addAll(usedPars);
		}
		else
			deadlineActionOp.parameters.add(parD);
        
        //Adding g into req_normal
        var variableListActOp = new Source!VariableList();
		variableListActOp.vars.add(gActOp);
		variableListActOp.modifier = VariableModifier#VAR;
        req_normal.variableList.add(variableListActOp);
		
		//Signature for deadlineAction
		var deadlineActionOpSig 	= new Source!OperationSig();
		deadlineActionOpSig.name 	= deadlineActionOp.name;
		
		// parameter for the deadlineAction operationSig - opSig
		var parDOpSig = new Source!Parameter();
		parDOpSig.name = "d";
		var parDtypeOpSig = new Source!TypeRef();
		parDtypeOpSig.ref = Source!PrimitiveType.all.selectOne(p|p.name="nat");
		parDOpSig.type = parDtypeOpSig;
		if(usedPars.notEmpty()){
		   usedParsOpSig.add(parDOpSig);
		   deadlineActionOpSig.parameters.addAll(usedParsOpSig);
		   }
		else
		   deadlineActionOpSig.parameters.add(parDOpSig);
		
		//Creating the call to the new operation deadllineAction_
		var call = new Source!Call();
		call.`operation` = deadlineActionOpSig;
		
		
		//Dealing with args (we need to create usedArgs)
		if (usedVarsParameters.notEmpty() and usedPars.notEmpty()){
		var seqArgs = new Sequence(Sorce!Expression);
		   for (p in opDef.parameters){
		     for (np in usedVarsParameters){
		       if (p.name.equals(np.name)){
		         var refExp = new Source!RefExp();
		         refExp.ref = np;
		         seqArgs.add(refExp);
		         //printDebug("opsig args " + np + " " + np.name + " " + np.type );
		         //printDebug("opsig refexp " + refExp  );
		       }
		     }
		     }
		     seqArgs.add(t.action.deadline);
		  call.args.addAll(seqArgs);
		}
		else
		   //Adding the parameter
		   call.args.add(t.action.deadline);
		   
		t.action = call;
		
		////////////////////////////////////////////////////////////////////////////////////////////////-
		// Declare an interface that contains the new operation	deadlineAction
		var IdeadlineAction = new Source!Interface();
		IdeadlineAction.name = "I_" + deadlineActionOp.name;
		IdeadlineAction.operations.add(deadlineActionOpSig);
		
		// Declare an interface that contains the new operation	normal_deadlineAction
		var IdeadlineActionOp_ActionOp  = new Source!Interface();
		IdeadlineActionOp_ActionOp.name = "I_" + deadlineActionOp_ActionOp.name;
		IdeadlineActionOp_ActionOp.operations.add(deadlineActionOp_ActionOpSig);
		
		// Add the interfaces to current package.
		pkg.interfaces.addAll(Set{IdeadlineAction,IdeadlineActionOp_ActionOp});
		
		// Make IdeadlineAction required by the original operation opDef.
		opDef.rInterfaces.add(IdeadlineAction);
		
		// Make IdeadlineActionOp_ActionOp required by the new operation deadlineAction (deadlineAction_).
		deadlineActionOp.rInterfaces.add(IdeadlineActionOp_ActionOp);
		
		// Delete the required and defined interfaces of deadlineActionOp if they are empty.
		// otherwise, we make them required by deadlineActionOp,
		// and introduce them in the package
		if (req_s.variableList.notEmpty() or req_s.operations.notEmpty() or req_s.clocks.notEmpty()){
		   deadlineActionOp.rInterfaces.add(req_s);
		   pkg.interfaces.add(req_s);
       }
		else
		   delete req_s;
		
		   
		if (req_normal.variableList.notEmpty() or req_normal.operations.notEmpty() or req_normal.clocks.notEmpty()){
		   deadlineActionOp_ActionOp.rInterfaces.add(req_normal);
		   pkg.interfaces.add(req_normal);
       }
       else 
       	   delete req_normal;
		if (defEvents_normal.events.notEmpty()){
		   deadlineActionOp.interfaces.add(defEvents_s);
		   deadlineActionOp_ActionOp.interfaces.add(defEvents_normal);
		   pkg.interfaces.addAll(Set{defEvents_s,defEvents_normal}); 
		}
		else {
		   delete defEvents_s;
		   delete defEvents_normal;
		   }
	
	
		// Adding the OperationDefs to current package.
		pkg.operations.addAll(Set{deadlineActionOp,deadlineActionOp_ActionOp});
		
		////////////////////////////////////////////////////////////////////////////////////////////////-	
		// For each ControllerDef in the set of all controllers 'c' in context (Source!ControllerDef)
		// for which the 'machines' attribute contains 'stm' or references 'stm', then introduce a
		// OperationRef element whose 'ref' attribute points to 'op'.
		for ( c : Source!ControllerDef 
				in select(c:Source!ControllerDef|c.lOperations.exists(op|getOperation(op)==opDef))) 
		{
			var opRef 	= new Source!OperationRef();
			opRef.ref 	= deadlineActionOp;
			opRef.name	= c.name + "_ref_" + deadlineActionOp.name;
			c.lOperations.add(opRef);
			var opRefActOp 	= new Source!OperationRef();
			opRefActOp.ref 	= deadlineActionOp_ActionOp;
			opRefActOp.name	= c.name + "_ref_" + deadlineActionOp_ActionOp.name;
			c.lOperations.add(opRefActOp);
			printDebug("Adding reference to operation in controller '" + c.name + "'");
		}
		////////////////////////////////////////////////////////////////////////////////////////////////-
	usedOpSig = new Set(Source!OperationSig);
	usedOpsNames = new Set(String);
	//clocks
	usedClocksNames = new Set(String);
	
	//variables
	usedVarsNames = new Set(String);

	//events
	usedEvsNames = new Set(String);
		
		
		if (debug)
		{
			//printDebug("IntroduceSimpleOperation");
			//for (ts in op.transitions) {
				//printDebug("Transition '" + ts.name + "' from '" + ts.source.name +  "' to '" + ts.target.name + "' (action: " + ts.action + ")");
			  printDebug("Exit Eliminate Deadline From Action in an Operation");
			//}
		}
	}
	
}
    

 
pattern eliminate_wait
	pkg : Source!RCPackage,
		//guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef from: pkg.operations,     
	t 	: Source!Transition from: opDef.transitions{
	match: 	
	        t.action.isKindOf(Source!Wait) and not(t.action.duration.isKindOf(Source!RangeExp))
	        and (t.trigger = null or (not (t.trigger = null) and t.trigger._type = TriggerType#EMPTY)) and 
	         t.deadline = null and t.condition = null 
	do { 
		
		
	    printDebug(" begin eliminate wait ");
	    
//	    for (i in pkg.interfaces){
//	      printDebug(" interface in pkg " + i.name);
//	    }
	    //get the operationsig waitOp
	    var interface = mainPackage.interfaces.selectOne(i | i.name = "IwaitOp");
	    printDebug(" interface " + interface);
		var waitOpSig = interface.operations.selectOne(op | op.name = "waitOp");
		
	    //create a Call
	    var callWaitOp = new Source!Call();
		callWaitOp.`operation` = waitOpSig;
		//args of the call 
		callWaitOp.args.add(t.action.duration);
		
		t.action = callWaitOp;
		
		opDef.rInterfaces.add(interface);
	    
	    
		if (debug) {
		    printDebug("end - eliminate wait"); 
		
		}
	}
}

pattern elim_nondeterministic_wait
	pkg : Source!RCPackage
		guard: pkg.name.asString().startsWith(clonepackagename),
	opDef : Source!OperationDef from: pkg.operations,     
	t 	: Source!Transition from: opDef.transitions{
	match: 	//not (t.source.isKindOf(Source!Initial)) and
	        t.action.isKindOf(Source!Wait) and t.action.duration.isKindOf(Source!RangeExp) 
	        and (t.trigger = null or (not (t.trigger = null) and t.trigger._type = TriggerType#EMPTY)) and 
	         t.deadline = null and t.condition = null 
	do { 
		
	    
	    printDebug(" begin elim_nondeterministic_wait ");
	    
	    //get the operationsig waitOp
	    var interface = mainPackage.interfaces.selectOne(i | i.name = "IwaitInterval");
		var waitIntervalSig = interface.operations.selectOne(op | op.name = "waitInterval");
	    
	    //create a call
	    var callWaitInterval = new Source!Call();
		callWaitInterval.`operation` = waitIntervalSig;
		//create the args
		var integer1 = new Source!IntegerExp();
		integer1.value = 1; 
		callWaitInterval.args.addAll(Sequence{t.action.duration.lrange,t.action.duration.rrange});
		
		t.action = callWaitInterval;
		
		opDef.rInterfaces.add(interface);
	    
	    
		if (debug) {
		    printDebug("end - elim_nondeterministic_wait"); 
		}
	}
}



	


