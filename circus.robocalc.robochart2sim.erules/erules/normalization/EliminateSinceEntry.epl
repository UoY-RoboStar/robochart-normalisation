import "../common/RoboChart.eol";
import "../common/Common.eol";

pre {
	// Controls whether debug information is printed.
	var debug = true;
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	
	var states = new Set(Source!State);
	var transitions = new Set(Source!Transition);
	//var mapStm2Sts = new Map(Source!StateMachine,Set(List<Source!State,Source!Transition>));
	//var mapStm2Sts2 = new Map(Source!StateMachine,Set(Source!State));
	//var mapStm2Trs = new Map(Source!StateMachine,Set(Source!Transition));
	//var mapSt2Trs = new Map(Source!State,Set(Source!Transition));
	//var setStTrs = new Set(List<Source!State,Source!Transition>);
	var mapSt2Clk = new Map(Source!State,Source!Clock);
	
	//We need an operation to find out the inner most state of a composite state
}

operation collectStateAndTrs(t:Source!Transition){
    
	if (t.condition<>null){
		var expressionContents = t.condition.closure(x|x.eContents());
        //printDebug( " expressionContents " + expressionContents);
        var st = expressionContents.select(y:Source!StateClockExp|true).collect(z:Source!StateClockExp|z.state).asSet();
        printDebug(" st " + st);
        if (st.size()>0){
        	 transitions.add(t);
        	 states.add(st.first());
        }
	}

}

operation collectStateAndTrs(stm:Source!StateMachineDef){

    for (t in stm.transitions){
	 	if (t.condition<>null){
			collectStateAndTrs(t);
		}
	}

	 for (st in stm.nodes.select(s|s.isTypeOf(Source!State) and s.nodes.size()>0)){
	  collectStateAndTrs(st);
	}
}


operation collectStateAndTrs(st:Source!State){
    for (t in st.transitions){
	 if (t.condition<>null){
		collectStateAndTrs(t);
	}
	}
	for (st1 in st.nodes.select(s|s.isTypeOf(Source!State) and s.nodes.size()>0)){
	  collectStateAndTrs(st1);
	}

}


pattern EliminateSinceEntry
        pkg : Source!RCPackage
        	guard: pkg.name.asString().startsWith(clonepackagename),
	smb : Source!StateMachineDef
		from: pkg.machines{
		//guard: //not smb.name.startsWith("clone_") and not smb.name.startsWith("normal_")
		       //and  not smb.name.startsWith("waitInterval") and not smb.name.startsWith("waitOp")
		       //{
	
	do{

     //We first collect the trasitions whose condition contains sinceEntry expressions
     //as well as the states used by such expressions
     printDebug("smb " + smb);
	 collectStateAndTrs(smb);
	 if (states.size()>0 and transitions.size()>0){
	    printDebug(" states " + states);
	    printDebug(" transitions " + transitions);
	 	eliminateSinceEntry(smb,states,transitions);
	 }

    //printDebug("mapStm2Sts " + mapStm2Sts);
    //states = new Set(Source!State);
	//trs = new Set(Source!Transition);
			
 }

}

operation eliminateSinceEntry(stm:Source!StateMachineDef,sts:Set(Source!State),trs:Set(Source!Transition)){
 
      for (st in sts){
      	//Creating a clock in stm for each state in 'sts'.
      	//Every state in 'sts' is used in a stateClockExpression
      	printDebug(" st " + st);
      	var clock = new Source!Clock();
     	clock.name = "ClkNF_"+ fullNameSt(st);
     	printDebug("clock.name " + clock.name);
	    //Adding the clock to stm
	    stm.clocks.add(clock);
	    
	    //Mapping clock => st
	    mapSt2Clk.put(st,clock);
      }
      
     for (tr in trs){
     //printDebug(" tr " + tr);
     var expressionContents = tr.condition.closure(x|x.eContents());
     printDebug( " expressionContents " + expressionContents);
     //We first collect the sinceEntry expression in tr
     var sinceEntryExps = expressionContents.select(y:Source!StateClockExp|true).asSet();
	 printDebug( " sinceEntryExps " + sinceEntryExps);
     //For each sinceEntry in sinceEntryExps, we create a clockExp
     for (sinceEntry in sinceEntryExps){
        //Here, we need to collect the state used by sinceEntry
        var clkExp = new Source!ClockExp();
        printDebug(" sinceEntry.state " + sinceEntry.state);
	    clkExp.clock=mapSt2Clk.get(sinceEntry.state);
     	//var usedSt = sinceEntry.collect(z:Source!StateClockExp|z.state).asSet();
     	//printDebug( " sinceEntryExps " + sinceEntryExps);
     	//var seExp = expressionContents.select(y:Source!StateClockExp|y.state=sinceEntry.state);
     	for (exp in expressionContents.select(y:Source!StateClockExp|y.state=sinceEntry.state))
	    {
	            printDebug("exp in statementContents " + exp + exp.state);
	            ecoreUtil.replace(exp,clkExp);
		}
     
     }
     //var usedSts = expressionContents.select(y:Source!StateClockExp|true).collect(z:Source!StateClockExp|z.state).asSet();
	 
//	 for (st in usedSts){
//	 	var clkExp = new Source!ClockExp();
//	    clkExp.clock=mapSt2Clk.get(st);
//	    var expC = expressionContents.select(y:Source!StateClockExp|y.state=st);
//	    
//	    
//	    //printDebug("exp in statementContents expC" + expC);
//	    
//	      for (exp in  expressionContents.select(y:Source!StateClockExp|y.state=st))
//	       {
//	            printDebug("exp in statementContents " + exp + exp.state);
//	            
//	            ecoreUtil.replace(exp,clkExp);
//				//exp = clkExp;//??
//				//exp = new Source!ClockExp();
//				//exp.clock=mapSt2Clk.get(st);
//				//printDebug(" exp in statementContents " + exp + exp.clock);
//		}
//	 }
	 //tr.condition = ??
    //error = x;
     
     }


}

//pattern EliminateSinceEntry
//	pkg : Source!RCPackage
//		guard: pkg.name.asString().startsWith(clonepackagename),
//	stm : Source!StateMachineDef from: pkg.machines,
//	//,  //NodeContainer
//	s 	: Source!State
//		// One of the states of stm
//	from: stm.closure(x:Source!NodeContainer|x.nodes)	      
//	{ 
//	match: 
//	//s.nodes.size() == 0 	       	       
//	//       and (stm.transitions.exists(t1| t1.source = s and (not(t1.condition=null) or ( not(t1.trigger=null)
//	//       )  ) ))
//	//       and not (stm.transitions.exists(t1| t1.source = s and (t1.condition=null) and (t1.trigger=null 
//	//       ) 
//	//       ) )
//	//       and ()
//	        	                                   
//	do {
//	  
//	   printDebug("Begin - Eliminate Since Entry ");
//	   printDebug("stm.name " + stm.name + " s.name " + s.name + " s.nodes " + s.nodes.size());
//	   
//	   var initial 	= new Source!Initial();
//	   initial.name	= "i";
//	   var state 	= new Source!State();
//	   state.name 	= "SEnd";// + fullNameSt(s);
//	   
//	   var transition = new Source!Transition();
//	   transition.name	  = "t" + s.name;
//	   transition.source = initial;
//	   transition.target = state;
//	  
//	  
//	   
//	   var clock = new Source!Clock();
//	   clock.name = "ClksinceEntryNF";
//	   stm.clocks.add(clock);
//	   var clockReset = new Source!ClockReset();
//	   clockReset.clock = clock;
//	   //transition.action = clockReset;
//	   
//	   var hasSinceEntry = false;
//	   
//	   //We may extend this rule to check weather of the guards is defined using sinceEntry
//	   for (t in stm.transitions.select(tr | tr.source = s)){
//	      if (t.condition <> null){
//	      	printDebug( "Dealing with sinceEntry expression");
//	      	printDebug( "stm.name: " + stm.name + " s.name: " + s.name + " t.name: " + t.name);
//	      	printDebug(" t.condition " + t.condition);
//	      	var expressionContents = t.condition.closure(x|x.eContents());
//	      	
//	      	printDebug( " expressionContents " + expressionContents);
//	   
//	      	var sinceEntryExp = expressionContents.select(y:Source!StateClockExp|true).collect(z:Source!StateClockExp|z.state).asSet();
//	        printDebug(" sinceEntryExp " + sinceEntryExp);
//	        if (sinceEntryExp.notEmpty()){
//	        	hasSinceEntry = true;
//	        	//We now need to replace sinceEntry to since
//	        	var cloneCondition = t.condition;
//	        	var sinceClk_NF = new Source!ClockExp;
//	        	sinceClk_NF.clock = clock;
//	        	for (exp in sinceEntryExp.select(x:Source!StateClockExp|true)) {
//					exp = sinceClk_NF;
//				}
//				printDebug(" new condition " + t.condition);	
//	        	//printDebug(" new condition " + xx);
//	        	var newTr = new Source!Transition();
//	        	newTr.name = t.name;
//	        	newTr.source = t.source;
//	        	newTr.target = t.target;
//	        	newTr.action = t.action;
//	        	newTr.trigger = t.trigger;
//	        	newTr.condition = cloneCondition;
//	        }
//	      }
//	   
//	   }
//	   
////	   if (hasSinceEntry){
////	   	  
////	   	  //we now create a reset clock
////	   	  var clockReset = new Source!ClockReset();
////	   	  clockReset.clock = clock;
////	   	  transition.action = clockReset;
////	   	  stm.clocks.add(clock);
////	   }
//	   
//	   s.nodes.addAll(Set{initial,state});
//	   s.transitions.addAll(Set{transition});
//	   
//	   printDebug("s.nodes.size " + s.nodes.size() + " s.name " + s.name);
//	   printDebug("End - IntroduceSEndState");
//	}
//	}