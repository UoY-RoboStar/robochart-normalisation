import "../common/Common.eol";

pre {
	// Controls whether debug information is printed.
	var debug = true;
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var ecoreUtil = emfTool.ecoreUtil;
	 
	var level = 0;
	var previouslevel = 0;
	var debugPrintRuleNames = true;
	var setAntFile = "normalForm.xml";
	var outputFolder = "normalForm/";
	
	// Controls whether intermediate models should be stored for debugging purposes.
	var storeIntermediateModels = true;
	
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	
	// RoboChart2Sim tools
	var tool = new Native("circus.robocalc.robochart2sim.textual.tools.Util");
}

// Rule to introduce deadlines operations (tStop and deadlineCheck) into the package, 
// and a reference to them into all controllers of the model
pattern EC2OSTM
	pkg : Source!RCPackage
		//guard: pkg.name.asString().startsWith(clonepackagename)
		{
 
	do {
	
	  for (stm in Source!StateMachineDef.all) {
	  
	    //var tool = new Native("circus.robocalc.robochart2sim.textual.tools.Util");
	
		//	  We create a new model repository 'mrep', and save the original repository.
		var mrep = tool.createModelRepository();
		var orep = System.context.getModelRepository();
		
		printDebug("Context: " + System.context);
		
		//COMPOSITE STATE
		var cs = stm.nodes.select(n | n.isTypeOf(Source!State) and n.nodes.size() > 0);
		  
//		for (n in cs){
//		   //var compS = n.equivalent();
//		   compositeState(n);
//		   }
		var o = tool.createModelInExistingResourceSet(stm,"OpenSTM",
		       projecturi + outputFolder + buildnumber + "/openstm/" + stm.name + "_rc_openstm.C2S",
			List{"http://www.robocalc.circus/C2S"}); 
			
		var openSTM = new RCBasicOpenStateMachine(); //Extract is here
		
		// Move transitions and nodes across, using the clone() method to ensure no
		// concurrent modification of the collection.
		openSTM.transitions = stm.transitions.clone();
		openSTM.nodes = stm.nodes.clone();
		
		// Attach element to the newly created Resource in the Epsilon model in variable 'o'.
		o.getResource().getContents.add(openSTM);
		
		printDebug("Added new OpenSTM to newly created resource");	
		
		// If the option to store intermediate models is on, we flag it to be stored
		// on disposal, so we can see on disk what is going on.
		if (storeIntermediateModels) {
			o.setStoredOnDisposal(true);
		}
		
		var task = project.createTask("ant");
				
		// We exchange the model repository, so Epsilon will act on a fresh set of
		// models, independently from those currently in this file.
		project.addReference("epsilon.modelRepository",mrep);
		
		// We set the target.
		task.setTarget("NormaliseOpenSTM");
		// We set it to inherit references, otherwise it cannot resolve names of models
		// and so forth within the ANT file.
		task.setInheritRefs(true);
		// We specify the file.
		//task.setAntFile("run-normalizationDeadlineDuring.xml");
		//task.setAntFile("run-rc2rs.xml");
		task.setAntFile(setAntFile);//"run-rc2rsStep1AppleHarvestControl.xml");
		// It needs some initialization, and then we can execute it.
		task.init();
		task.execute();
		
		// After successful execution of the above, the model in 'o' should hold a normalised
		// RCOpenStateMachine. We save it to disk to allow inspection of intermediate results.
		o.store();
		
		//////////////////////////////////////////////////////////////////////////////////////
		// EPSILON ANT-specific tasks
		//
		// At the end, we restore the original modelrepository after having completed the task.
		project.addReference("epsilon.modelRepository",orep);
		// And dispose of the new model repository. If there are any models set with
		// setStoredOnDisposal, even if they were not saved, they should be saved by this time.
		//
		// This disposes the model repository we created.
		mrep.dispose();
		printDebug("Disposed of new model repository.");
	
	}
	
}
}

operation compositeState(n:Source!State){
   
   printDebug("Composite State: " + n.name);
		
		//var tool = new Native("circus.robocalc.robochart2sim.textual.tools.Util");
		//	  We create a new model repository 'mrep', and save the original repository.
		var mrep = tool.createModelRepository();
		var orep = System.context.getModelRepository();
		// We need a 'recursion' here, because the nodes in this
		// state may themselves require application of this rule.
		//
		// Is this correct?
		//increaseDebug();
		//var nodes = s.nodes.clone(); // equivalent();
		//var transitions = s.transitions.clone();   //equivalent();
		//decreaseDebug();
		
		// At this point we define what happens after having
		// done the recursive case. We pick the 'Intermediate'
		// model, and apply the rules in the traditional ANT
		// file for openstms.
		//
		// TODO: (1) Check that this indeed works as expected.
		// 		 (2) Automate this in the future using Java/Epsilon, to remove the
		//			 dependency on ANT. This would be an interesting avenue to
		// 			 define an extension of ETL that could describe the application
		// 			 of such programs/rules directly in the language.
		//
		// NOTE: equivalent/equivalents allows specifying which rules will be applied,
		// 		 but we cannot use EPL patterns here, which is the problem.
		//
		
		//Composite states
		var cs = n.nodes.select(n1 | n1.isTypeOf(Source!State) and n1.nodes.size() > 0);
		for (s in cs){
			compositeState(s);
		}
		
		var o = tool.createModelInExistingResourceSet(n,"OpenSTM",
		       projecturi + outputFolder + buildnumber + "/openstm/" + n.name + "_rc_openstm.C2S",
			List{"http://www.robocalc.circus/C2S"});
			
		var openSTM = new RCBasicOpenStateMachine(); 
		
		openSTM.transitions = n.transitions.clone();
		openSTM.nodes = n.nodes.clone();
		
		o.getResource().getContents.add(openSTM);
		
		printDebug("Added new OpenSTM to newly created resource");	
		
		// If the option to store intermediate models is on, we flag it to be stored
		// on disposal, so we can see on disk what is going on.
		if (storeIntermediateModels) {
			o.setStoredOnDisposal(true);
		}
		
		project.addReference("epsilon.modelRepository",mrep);
		// We dynamically create a new ANT task within the current project.
		var task = project.createTask("ant");
				
		// We exchange the model repository, so Epsilon will act on a fresh set of
		// models, independently from those currently in this file.
		project.addReference("epsilon.modelRepository",mrep);
		
		//////////////////////////////////////////////////////////////////////////////////////
		// EPSILON ANT-specific tasks
		//
		// TODO: Perhaps could move this into an operation call. It is, however, unfortunate
		// 		 that we cannot move this into our Java tool class, as ANT classes are loaded
		//		 by a different class loader.
		//
		// We set the target.
		task.setTarget("NormaliseOpenSTM");
		// We set it to inherit references, otherwise it cannot resolve names of models
		// and so forth within the ANT file.
		task.setInheritRefs(true);
		// We specify the file.
		//task.setAntFile("run-normalizationDeadlineDuring.xml");
		//task.setAntFile("run-rc2rs.xml");
		task.setAntFile(setAntFile);//"run-rc2rsStep1AppleHarvestControl.xml");
		// It needs some initialization, and then we can execute it.
		task.init();
		task.execute();
		////////////////////////////////////////////////////////////////////////////////////-
		
		// After successful execution of the above, the model in 'o' should hold a normalised
		// RCOpenStateMachine. We save it to disk to allow inspection of intermediate results.
		o.store();
		
		// At the end, we restore the original modelrepository after having completed the task.
		project.addReference("epsilon.modelRepository",orep);
		
		// This disposes the model repository we created.
		mrep.dispose();
		printDebug("Disposed of new model repository.");

}